<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>lib/word-filter.js - editor-plugins</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title="editor-plugins"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: editor-plugins 1.1.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/BackColor.html">BackColor</a></li>
            
                <li><a href="../classes/Bold.html">Bold</a></li>
            
                <li><a href="../classes/Button.html">Button</a></li>
            
                <li><a href="../classes/CheckBoxSourceArea.html">CheckBoxSourceArea</a></li>
            
                <li><a href="../classes/Code.html">Code</a></li>
            
                <li><a href="../classes/Draft.html">Draft</a></li>
            
                <li><a href="../classes/DragUpload.html">DragUpload</a></li>
            
                <li><a href="../classes/ElementPath.html">ElementPath</a></li>
            
                <li><a href="../classes/Flash.html">Flash</a></li>
            
                <li><a href="../classes/FontColor.html">FontColor</a></li>
            
                <li><a href="../classes/FontFamily.html">FontFamily</a></li>
            
                <li><a href="../classes/FontSize.html">FontSize</a></li>
            
                <li><a href="../classes/Heading.html">Heading</a></li>
            
                <li><a href="../classes/Image.html">Image</a></li>
            
                <li><a href="../classes/Indent.html">Indent</a></li>
            
                <li><a href="../classes/Italic.html">Italic</a></li>
            
                <li><a href="../classes/JustifyCenter.html">JustifyCenter</a></li>
            
                <li><a href="../classes/JustifyLeft.html">JustifyLeft</a></li>
            
                <li><a href="../classes/JustifyRight.html">JustifyRight</a></li>
            
                <li><a href="../classes/Link.html">Link</a></li>
            
                <li><a href="../classes/Maximize.html">Maximize</a></li>
            
                <li><a href="../classes/MultipleUpload.html">MultipleUpload</a></li>
            
                <li><a href="../classes/OrderedList.html">OrderedList</a></li>
            
                <li><a href="../classes/Outdent.html">Outdent</a></li>
            
                <li><a href="../classes/PageBreak.html">PageBreak</a></li>
            
                <li><a href="../classes/Preview.html">Preview</a></li>
            
                <li><a href="../classes/RemoveFormat.html">RemoveFormat</a></li>
            
                <li><a href="../classes/Resize.html">Resize</a></li>
            
                <li><a href="../classes/Separator.html">Separator</a></li>
            
                <li><a href="../classes/Smiley.html">Smiley</a></li>
            
                <li><a href="../classes/SourceArea.html">SourceArea</a></li>
            
                <li><a href="../classes/StrikeThrough.html">StrikeThrough</a></li>
            
                <li><a href="../classes/Table.html">Table</a></li>
            
                <li><a href="../classes/Underline.html">Underline</a></li>
            
                <li><a href="../classes/Undo.html">Undo</a></li>
            
                <li><a href="../classes/UnorderedList.html">UnorderedList</a></li>
            
                <li><a href="../classes/Video.html">Video</a></li>
            
                <li><a href="../classes/XiaMiMusic.html">XiaMiMusic</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/back-color.html">back-color</a></li>
            
                <li><a href="../modules/bold.html">bold</a></li>
            
                <li><a href="../modules/button.html">button</a></li>
            
                <li><a href="../modules/checkbox-source-area.html">checkbox-source-area</a></li>
            
                <li><a href="../modules/code.html">code</a></li>
            
                <li><a href="../modules/draft.html">draft</a></li>
            
                <li><a href="../modules/drag-upload.html">drag-upload</a></li>
            
                <li><a href="../modules/eindent.html">eindent</a></li>
            
                <li><a href="../modules/element-path.html">element-path</a></li>
            
                <li><a href="../modules/flash.html">flash</a></li>
            
                <li><a href="../modules/font-color.html">font-color</a></li>
            
                <li><a href="../modules/font-family.html">font-family</a></li>
            
                <li><a href="../modules/font-size.html">font-size</a></li>
            
                <li><a href="../modules/heading.html">heading</a></li>
            
                <li><a href="../modules/image.html">image</a></li>
            
                <li><a href="../modules/italic.html">italic</a></li>
            
                <li><a href="../modules/justify-center.html">justify-center</a></li>
            
                <li><a href="../modules/justify-left.html">justify-left</a></li>
            
                <li><a href="../modules/justify-right.html">justify-right</a></li>
            
                <li><a href="../modules/link.html">link</a></li>
            
                <li><a href="../modules/maximize.html">maximize</a></li>
            
                <li><a href="../modules/multiple-upload.html">multiple-upload</a></li>
            
                <li><a href="../modules/ordered-list.html">ordered-list</a></li>
            
                <li><a href="../modules/outdent.html">outdent</a></li>
            
                <li><a href="../modules/page-break.html">page-break</a></li>
            
                <li><a href="../modules/preview.html">preview</a></li>
            
                <li><a href="../modules/remove-format.html">remove-format</a></li>
            
                <li><a href="../modules/resize.html">resize</a></li>
            
                <li><a href="../modules/separator.html">separator</a></li>
            
                <li><a href="../modules/smiley.html">smiley</a></li>
            
                <li><a href="../modules/source-area.html">source-area</a></li>
            
                <li><a href="../modules/strike-through.html">strike-through</a></li>
            
                <li><a href="../modules/table.html">table</a></li>
            
                <li><a href="../modules/underline.html">underline</a></li>
            
                <li><a href="../modules/undo.html">undo</a></li>
            
                <li><a href="../modules/unordered-list.html">unordered-list</a></li>
            
                <li><a href="../modules/video.html">video</a></li>
            
                <li><a href="../modules/xiami-music.html">xiami-music</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: lib/word-filter.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
 * @ignore
 * clean html pasted from word. modified from ckeditor.
 * @author yiminghe@gmail.com
 */

/*jshint loopfunc:true*/
var HtmlParser = require(&#x27;html-parser&#x27;);
var util = require(&#x27;util&#x27;);
var $ = require(&#x27;node&#x27;),
    UA = require(&#x27;ua&#x27;),
    dtd = HtmlParser.DTD,
    wordFilter = new HtmlParser.Filter(),
    cssLengthRelativeUnit = /^([.\d]*)+(em|ex|px|gd|rem|vw|vh|vm|ch|mm|cm|in|pt|pc|deg|rad|ms|s|hz|khz){1}?/i,
// e.g. 0px 0pt 0px
    emptyMarginRegex = /^(?:\b0[^\s]*\s*){1,4}$/,
    romanLiteralPattern = &#x27;^m{0,4}(cm|cd|d?c{0,3})(xc|xl|l?x{0,3})(ix|iv|v?i{0,3})$&#x27;,
    lowerRomanLiteralRegex = new RegExp(romanLiteralPattern),
    upperRomanLiteralRegex = new RegExp(romanLiteralPattern.toUpperCase()),
    orderedPatterns = {
        &#x27;decimal&#x27;: /\d+/,
        &#x27;lower-roman&#x27;: lowerRomanLiteralRegex,
        &#x27;upper-roman&#x27;: upperRomanLiteralRegex,
        &#x27;lower-alpha&#x27;: /^[a-z]+$/,
        &#x27;upper-alpha&#x27;: /^[A-Z]+$/
    },
    unorderedPatterns = {
        &#x27;disc&#x27;: /[l\u00B7\u2002]/,
        &#x27;circle&#x27;: /[\u006F\u00D8]/,
        &#x27;square&#x27;: /[\u006E\u25C6]/
    },
    listMarkerPatterns = {
        &#x27;ol&#x27;: orderedPatterns,
        &#x27;ul&#x27;: unorderedPatterns
    },
    romans = [
        [1000, &#x27;M&#x27;],
        [900, &#x27;CM&#x27;],
        [500, &#x27;D&#x27;],
        [400, &#x27;CD&#x27;],
        [100, &#x27;C&#x27;],
        [90, &#x27;XC&#x27;],
        [50, &#x27;L&#x27;],
        [40, &#x27;XL&#x27;],
        [10, &#x27;X&#x27;],
        [9, &#x27;IX&#x27;],
        [5, &#x27;V&#x27;],
        [4, &#x27;IV&#x27;],
        [1, &#x27;I&#x27;]
    ],
    alphabets = &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;;

// Convert roman numbering back to decimal.
function fromRoman(str) {
    str = str.toUpperCase();
    var l = romans.length, retVal = 0;
    for (var i = 0; i &lt; l; ++i) {
        for (var j = romans[i], k = j[1].length; str.substr(0, k) === j[1]; str = str.substr(k)) {
            retVal += j[ 0 ];
        }
    }
    return retVal;
}

// Convert alphabet numbering back to decimal.
function fromAlphabet(str) {
    str = str.toUpperCase();
    var l = alphabets.length, retVal = 1;
    for (var x = 1; str.length &gt; 0; x *= l) {
        retVal += alphabets.indexOf(str.charAt(str.length - 1)) * x;
        str = str.substr(0, str.length - 1);
    }
    return retVal;
}

function setStyle(element, str) {
    if (str) {
        element.setAttribute(&#x27;style&#x27;, str);
    } else {
        element.removeAttribute(&#x27;style&#x27;);
    }
}

/*
 Convert the specified CSS length value to the calculated pixel length inside this page.
 &lt;strong&gt;Note:&lt;/strong&gt; Percentage based value is left intact.
 */
var convertToPx = (function () {
    var calculator;

    return function (cssLength) {
        if (!calculator) {
            calculator = $(&#x27;&lt;div style=&quot;position:absolute;left:-9999px;&#x27; +
                &#x27;top:-9999px;margin:0px;padding:0px;border:0px;&quot;&#x27; + &#x27;&gt;&lt;/div&gt;&#x27;)
                .prependTo(&#x27;body&#x27;);
        }

        if (!(/%$/).test(cssLength)) {
            calculator.css(&#x27;width&#x27;, cssLength);
            return calculator[0].clientWidth;
        }

        return cssLength;
    };
})();

var listBaseIndent = 0,
    previousListItemMargin = null,
    previousListId;

function onlyChild(elem) {
    var childNodes = elem.childNodes || [],
        count = childNodes.length,
        firstChild = (count === 1) &amp;&amp; childNodes[0];
    return firstChild || null;
}

function removeAnyChildWithName(elem, tagName) {
    var children = elem.childNodes || [],
        ret = [],
        child;

    for (var i = 0; i &lt; children.length; i++) {
        child = children[ i ];
        if (!child.nodeName) {
            continue;
        }
        if (child.nodeName === tagName) {
            ret.push(child);
            children.splice(i--, 1);
        }
        ret = ret.concat(removeAnyChildWithName(child, tagName));
    }
    return ret;
}

function getAncestor(elem, tagNameRegex) {
    var parent = elem.parentNode;
    while (parent &amp;&amp; !( parent.nodeName &amp;&amp; parent.nodeName.match(tagNameRegex) )) {
        parent = parent.parentNode;
    }
    return parent;
}

function firstChild(elem, evaluator) {
    var child,
        i,
        children = elem.childNodes || [];

    for (i = 0; i &lt; children.length; i++) {
        child = children[ i ];
        if (evaluator(child)) {
            return child;
        } else if (child.nodeName) {
            child = firstChild(child, evaluator);
            if (child) {
                return child;
            }
        }
    }

    return null;
}


function addStyle(elem, name, value, isPrepend) {
    var styleText, addingStyleText = &#x27;&#x27;, style;
    // name/value pair.
    if (typeof value === &#x27;string&#x27;) {
        addingStyleText += name + &#x27;:&#x27; + value + &#x27;;&#x27;;
    } else {
        // style literal.
        if (typeof name === &#x27;object&#x27;) {
            for (style in name) {

                addingStyleText += style + &#x27;:&#x27; + name[ style ] + &#x27;;&#x27;;

            }
        }
        // raw style text form.
        else {
            addingStyleText += name;
        }
        isPrepend = value;
    }


    styleText = elem.getAttribute(&#x27;style&#x27;);

    styleText = ( isPrepend ?
        [ addingStyleText, styleText ]
        : [ styleText, addingStyleText ] ).join(&#x27;;&#x27;);

    setStyle(elem, styleText.replace(/^;|;(?=;)/, &#x27;&#x27;));
}


function parentOf(tagName) {
    var result = {},
        tag;
    for (tag in dtd) {

        if (tag.indexOf(&#x27;$&#x27;) === -1 &amp;&amp; dtd[ tag ][ tagName ]) {
            result[ tag ] = 1;
        }

    }
    return result;
}

var filters = {
    // Transform a normal list into flat list items only presentation.
    // E.g. &lt;ul&gt;&lt;li&gt;level1&lt;ol&gt;&lt;li&gt;level2&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt; =&gt;
    // &lt;ke:li ke:listtype=&#x27;ul&#x27; ke:indent=&#x27;1&#x27;&gt;level1&lt;/ke:li&gt;
    // &lt;ke:li ke:listtype=&#x27;ol&#x27; ke:indent=&#x27;2&#x27;&gt;level2&lt;/ke:li&gt;
    flattenList: function (element, level) {
        level = typeof level === &#x27;number&#x27; ? level : 1;

        var listStyleType;

        // All list items are of the same type.
        switch (element.getAttribute(&#x27;type&#x27;)) {
            case &#x27;a&#x27; :
                listStyleType = &#x27;lower-alpha&#x27;;
                break;
            case &#x27;1&#x27; :
                listStyleType = &#x27;decimal&#x27;;
                break;
            // TODO: Support more list style type from MS-Word.
        }

        var children = element.childNodes || [],
            child;

        for (var i = 0; i &lt; children.length; i++) {
            child = children[ i ];

            if (child.nodeName in dtd.$listItem) {
                var listItemChildren = child.childNodes || [],
                    count = listItemChildren.length,
                    last = listItemChildren[ count - 1 ];

                // Move out nested list.
                if (last.nodeName in dtd.$list) {
                    element.insertAfter(child);
                    // Remove the parent list item if it&#x27;s just a holder.
                    if (!--listItemChildren.length) {
                        element.removeChild(children[i--]);
                    }
                }

                child.setTagName(&#x27;ke:li&#x27;);

                // Inherit numbering from list root on the first list item.
                if (element.getAttribute(&#x27;start&#x27;) &amp;&amp; !i) {
                    element.setAttribute(&#x27;value&#x27;, element.getAttribute(&#x27;start&#x27;));
                }

                filters.stylesFilter(
                    [
                        [&#x27;tab-stops&#x27;, null, function (val) {
                            var margin = val.split(&#x27; &#x27;)[ 1 ].match(cssLengthRelativeUnit);
                            if (margin) {
                                ( previousListItemMargin = convertToPx(margin[ 0 ]) );
                            }
                        }
                        ],
                        ( level === 1 ? [ &#x27;mso-list&#x27;, null, function (val) {
                            val = val.split(&#x27; &#x27;);
                            var listId = Number(val[ 0 ].match(/\d+/));
                            if (listId !== previousListId) {
                                child.setAttribute(&#x27;ke:reset&#x27;, 1);
                            }
                            previousListId = listId;
                        } ] : null )
                    ])(child.getAttribute(&#x27;style&#x27;));

                child.setAttribute(&#x27;ke:indent&#x27;, level);
                child.setAttribute(&#x27;ke:listtype&#x27;, element.nodeName);
                child.setAttribute(&#x27;ke:list-style-type&#x27;, listStyleType);
            }
            // Flatten sub list.
            else if (child.nodeName in dtd.$list) {
                /*jshint noarg:false*/
                // Absorb sub list children.
                arguments.callee.apply(this, [ child, level + 1 ]);
                children = children.slice(0, i).concat(child.childNodes).concat(children.slice(i + 1));
                element.empty();
                for (var j = 0, num = children.length; j &lt; num; j++) {
                    element.appendChild(children[j]);
                }
            }
        }

        element.nodeName = element.tagName = null;

        // We&#x27;re loosing tag name here, signalize this element as a list.
        element.setAttribute(&#x27;ke:list&#x27;, 1);
    },

    /*
     Try to collect all list items among the children and establish one
     or more HTML list structures for them.
     */
    assembleList: function (element) {
        var children = element.childNodes || [],
            child,
            listItem, // The current processing ke:li element.
            listItemIndent, // Indent level of current list item.
            lastIndent,
            lastListItem, // The previous one just been added to the list.
            list, // Current staging list and it&#x27;s parent list if any.
            openedLists = [],
            previousListStyleType,
            previousListType;

        // Properties of the list item are to be resolved from the list bullet.
        var bullet,
            listType,
            listStyleType,
            itemNumeric;

        for (var i = 0; i &lt; children.length; i++) {
            child = children[ i ];

            if (&#x27;ke:li&#x27; === child.nodeName) {
                child.setTagName(&#x27;li&#x27;);
                listItem = child;

                bullet = listItem.getAttribute(&#x27;ke:listsymbol&#x27;);
                bullet = bullet &amp;&amp; bullet.match(/^(?:[(]?)([^\s]+?)([.)]?)$/);
                listType = listStyleType = itemNumeric = null;

                if (listItem.getAttribute(&#x27;ke:ignored&#x27;)) {
                    children.splice(i--, 1);
                    continue;
                }


                // This&#x27;s from a new list root.
                if (listItem.getAttribute(&#x27;ke:reset&#x27;)) {
                    ( list = lastIndent = lastListItem = null );
                }

                // List item indent level might come from a real list indentation or
                // been resolved from a pseudo list item&#x27;s margin value, even get
                // no indentation at all.
                listItemIndent = Number(listItem.getAttribute(&#x27;ke:indent&#x27;));

                // We&#x27;re moving out of the current list, cleaning up.
                if (listItemIndent !== lastIndent) {
                    previousListType = previousListStyleType = null;
                }

                // List type and item style are already resolved.
                if (!bullet) {
                    listType = listItem.getAttribute(&#x27;ke:listtype&#x27;) || &#x27;ol&#x27;;
                    listStyleType = listItem.getAttribute(&#x27;ke:list-style-type&#x27;);
                }
                else {
                    // Probably share the same list style type with previous list item,
                    // give it priority to avoid ambiguous between C(Alpha) and C.(Roman).
                    if (previousListType &amp;&amp;
                        listMarkerPatterns[ previousListType ] [ previousListStyleType ].test(bullet[ 1 ])) {
                        listType = previousListType;
                        listStyleType = previousListStyleType;
                    }
                    else {
                        for (var type in listMarkerPatterns) {

                            for (var style in listMarkerPatterns[ type ]) {

                                if (listMarkerPatterns[ type ][ style ].test(bullet[ 1 ])) {
                                    // Small numbering has higher priority, when dealing with ambiguous
                                    // between C(Alpha) and C.(Roman).
                                    if (type === &#x27;ol&#x27; &amp;&amp; ( /alpha|roman/ ).test(style)) {
                                        var num = /roman/.test(style) ? fromRoman(bullet[ 1 ]) : fromAlphabet(bullet[ 1 ]);
                                        if (!itemNumeric || num &lt; itemNumeric) {
                                            itemNumeric = num;
                                            listType = type;
                                            listStyleType = style;
                                        }
                                    }
                                    else {
                                        listType = type;
                                        listStyleType = style;
                                        break;
                                    }
                                }
                            }
                        }
                    }

                    // Simply use decimal/disc for the rest forms of unrepresentable
                    // numerals, e.g. Chinese..., but as long as there a second part
                    // included, it has a bigger chance of being a order list ;)
                    if (!listType) {
                        ( listType = bullet[ 2 ] ? &#x27;ol&#x27; : &#x27;ul&#x27; );
                    }
                }

                previousListType = listType;
                previousListStyleType = listStyleType || ( listType === &#x27;ol&#x27; ? &#x27;decimal&#x27; : &#x27;disc&#x27; );
                if (listStyleType &amp;&amp; listStyleType !== ( listType === &#x27;ol&#x27; ? &#x27;decimal&#x27; : &#x27;disc&#x27; )) {
                    addStyle(listItem, &#x27;list-style-type&#x27;, listStyleType);
                }

                // Figure out start numbering.
                if (listType === &#x27;ol&#x27; &amp;&amp; bullet) {
                    switch (listStyleType) {
                        case &#x27;decimal&#x27; :
                            itemNumeric = Number(bullet[ 1 ]);
                            break;
                        case &#x27;lower-roman&#x27;:
                        case &#x27;upper-roman&#x27;:
                            itemNumeric = fromRoman(bullet[ 1 ]);
                            break;
                        case &#x27;lower-alpha&#x27;:
                        case &#x27;upper-alpha&#x27;:
                            itemNumeric = fromAlphabet(bullet[ 1 ]);
                            break;
                    }

                    // Always create the numbering, swipe out unnecessary ones later.
                    listItem.setAttribute(&#x27;value&#x27;, itemNumeric);
                }

                // Start the list construction.
                if (!list) {
                    openedLists.push(list = new HtmlParser.Tag(listType));
                    list.appendChild(listItem);
                    element.replaceChild(list, children[i]);
                } else {
                    if (listItemIndent &gt; lastIndent) {
                        openedLists.push(list = new HtmlParser.Tag(listType));
                        list.appendChild(listItem);
                        lastListItem.appendChild(list);
                    }
                    else if (listItemIndent &lt; lastIndent) {
                        // There might be a negative gap between two list levels. (#4944)
                        var diff = lastIndent - listItemIndent,
                            parent;
                        while (diff-- &amp;&amp; ( parent = list.parentNode )) {
                            list = parent.parentNode;
                        }
                        list.appendChild(listItem);
                    }
                    else {
                        list.appendChild(listItem);
                    }
                    children.splice(i--, 1);
                }

                lastListItem = listItem;
                lastIndent = listItemIndent;
            }
            else if (list &amp;&amp; !(child.nodeType === 3 &amp;&amp; !util.trim(child.nodeValue))) {
                list = lastIndent = lastListItem = null;
            }
        }

        for (i = 0; i &lt; openedLists.length; i++) {
            postProcessList(openedLists[ i ]);
        }
    },

    /*
     A simple filter which always rejecting.
     */
    falsyFilter: function () {
        return false;
    },

    /*
     A filter dedicated on the &#x27;style&#x27; attribute filtering, e.g. dropping/replacing style properties.
     @param styles {Array} in form of [ styleNameRegexp, styleValueRegexp,
     newStyleValue/newStyleGenerator, newStyleName ] where only the first
     parameter is mandatory.
     @param [whitelist] {Boolean} Whether the {@param styles} will be considered as a white-list.
     */
    stylesFilter: function (styles, whitelist) {
        return function (styleText, element) {
            var rules = [];
            // html-encoded quote might be introduced by &#x27;font-family&#x27;
            // from MS-Word which confused the following regexp. e.g.
            //&#x27;font-family: &amp;quot;Lucida, Console&amp;quot;&#x27;
            ( styleText || &#x27;&#x27; )
                .replace(/&amp;quot;/g, &#x27;&quot;&#x27;)
                .replace(/\s*([^ :;]+)\s*:\s*([^;]+)\s*(?=;|$)/g,
                function (match, name, value) {
                    name = name.toLowerCase();
                    if (name === &#x27;font-family&#x27;) {
                        ( value = value.replace(/[&#x27;&#x27;]/g, &#x27;&#x27;) );
                    }

                    var namePattern,
                        valuePattern,
                        newValue,
                        newName;
                    for (var i = 0; i &lt; styles.length; i++) {
                        if (styles[ i ]) {
                            namePattern = styles[ i ][ 0 ];
                            valuePattern = styles[ i ][ 1 ];
                            newValue = styles[ i ][ 2 ];
                            newName = styles[ i ][ 3 ];

                            if (name.match(namePattern) &amp;&amp; ( !valuePattern || value.match(valuePattern) )) {
                                name = newName || name;
                                if (whitelist) {
                                    ( newValue = newValue || value );
                                }

                                if (typeof newValue === &#x27;function&#x27;) {
                                    newValue = newValue(value, element, name);
                                }

                                // Return an couple indicate both name and value
                                // changed.
                                if (newValue &amp;&amp; newValue.push) {
                                    name = newValue[ 0 ];
                                    newValue = newValue[ 1 ];
                                }

                                if (typeof newValue === &#x27;string&#x27;) {
                                    rules.push([ name, newValue ]);
                                }

                                return;
                            }
                        }
                    }

                    if (!whitelist) {
                        rules.push([ name, value ]);
                    }

                });

            for (var i = 0; i &lt; rules.length; i++) {
                rules[ i ] = rules[ i ].join(&#x27;:&#x27;);
            }

            return rules.length ? ( rules.join(&#x27;;&#x27;) + &#x27;;&#x27; ) : false;
        };
    },

    /*
     A filter which will be used to apply inline css style according the stylesheet
     definition rules, is generated lazily when filtering.
     */
    applyStyleFilter: null

};


// 1. move consistent list item styles up to list root.
// 2. clear out unnecessary list item numbering.
function postProcessList(list) {
    var children = list.childNodes || [],
        child,
        count = children.length,
        match,
        mergeStyle,
        styleTypeRegexp = /list-style-type:(.*?)(?:;|$)/,
        stylesFilter = filters.stylesFilter;


    if (styleTypeRegexp.exec(list.getAttribute(&#x27;style&#x27;))) {
        return;
    }

    for (var i = 0; i &lt; count; i++) {
        child = children[ i ];

        if (child.getAttribute(&#x27;value&#x27;) &amp;&amp; Number(child.getAttribute(&#x27;value&#x27;)) === i + 1) {
            child.removeAttribute(&#x27;value&#x27;);
        }

        match = styleTypeRegexp.exec(child.getAttribute(&#x27;style&#x27;));

        if (match) {
            if (match[ 1 ] === mergeStyle || !mergeStyle) {
                mergeStyle = match[ 1 ];
            }
            else {
                mergeStyle = null;
                break;
            }
        }
    }

    if (mergeStyle) {
        for (i = 0; i &lt; count; i++) {
            var style = children[ i ].getAttribute(&#x27;style&#x27;);

            if (style) {
                style = stylesFilter([
                    [ &#x27;list-style-type&#x27;]
                ])(style);
                setStyle(children[ i ], style);
            }
        }
        addStyle(list, &#x27;list-style-type&#x27;, mergeStyle);
    }
}

var utils = {
    // Create a &lt;ke:listbullet&gt; which indicate an list item type.
    createListBulletMarker: function (bullet, bulletText) {
        var marker = new HtmlParser.Tag(&#x27;ke:listbullet&#x27;);
        marker.setAttribute(&#x27;ke:listsymbol&#x27;, bullet[ 0 ]);
        marker.appendChild(new HtmlParser.Text(bulletText));
        return marker;
    },

    isListBulletIndicator: function (element) {
        var styleText = element.getAttribute(&#x27;style&#x27;);
        if (/mso-list\s*:\s*Ignore/i.test(styleText)) {
            return true;
        }
    },

    isContainingOnlySpaces: function (element) {
        var text;
        return ( ( text = onlyChild(element) ) &amp;&amp; ( /^(:?\s|&amp;nbsp;)+$/ ).test(text.nodeValue) );
    },

    resolveList: function (element) {
        // &lt;ke:listbullet&gt; indicate a list item.
        var listMarker;

        if (( listMarker = removeAnyChildWithName(element, &#x27;ke:listbullet&#x27;) ) &amp;&amp;
            listMarker.length &amp;&amp; ( listMarker = listMarker[ 0 ] )) {
            element.setTagName(&#x27;ke:li&#x27;);

            if (element.getAttribute(&#x27;style&#x27;)) {
                var styleStr = filters.stylesFilter(
                    [
                        // Text-indent is not representing list item level any more.
                        [ &#x27;text-indent&#x27; ],
                        [ &#x27;line-height&#x27; ],
                        // First attempt is to resolve indent level from on a constant margin increment.
                        [ ( /^margin(:?-left)?$/ ), null, function (margin) {
                            // Deal with component/short-hand form.
                            var values = margin.split(&#x27; &#x27;);
                            margin = convertToPx(values[ 3 ] || values[ 1 ] || values [ 0 ]);

                            // Figure out the indent unit by checking the first time of incrementation.
                            if (!listBaseIndent &amp;&amp; previousListItemMargin !== null &amp;&amp;
                                margin &gt; previousListItemMargin) {
                                listBaseIndent = margin - previousListItemMargin;
                            }

                            previousListItemMargin = margin;
                            if (listBaseIndent) {
                                element.setAttribute(&#x27;ke:indent&#x27;, listBaseIndent &amp;&amp;
                                    ( Math.ceil(margin / listBaseIndent) + 1 ) || 1);
                            }
                        } ],
                        // The best situation: &#x27;mso-list:l0 level1 lfo2&#x27; tells the belonged list root, list item indentation, etc.
                        [ ( /^mso-list$/ ), null, function (val) {
                            val = val.split(&#x27; &#x27;);
                            var listId = Number(val[ 0 ].match(/\d+/)),
                                indent = Number(val[ 1 ].match(/\d+/));

                            if (indent === 1) {
                                if (listId !== previousListId) {
                                    ( element.setAttribute(&#x27;ke:reset&#x27;, 1) );
                                }

                                previousListId = listId;
                            }
                            element.setAttribute(&#x27;ke:indent&#x27;, indent);
                        } ]
                    ])(element.getAttribute(&#x27;style&#x27;), element);

                setStyle(element, styleStr);
            }

            // First level list item might be presented without a margin.
            // In case all above doesn&#x27;t apply.
            if (!element.getAttribute(&#x27;ke:indent&#x27;)) {
                previousListItemMargin = 0;
                element.setAttribute(&#x27;ke:indent&#x27;, 1);
            }

            util.each(listMarker.attributes, function (a) {
                element.setAttribute(a.name, a.value);
            });

            return true;
        }
        // Current list disconnected.
        else {
            previousListId = previousListItemMargin = listBaseIndent = null;
        }
        return false;
    },

    // Providing a shorthand style then retrieve one or more style component values.
    getStyleComponents: (function () {
        var calculator = $(&#x27;&lt;div style=&quot;position:absolute;left:-9999px;top:-9999px;&quot;&gt;&lt;/div&gt;&#x27;).prependTo(&#x27;body&#x27;);

        return function (name, styleValue, fetchList) {
            calculator.css(name, styleValue);
            var styles = {},
                count = fetchList.length;
            for (var i = 0; i &lt; count; i++) {
                styles[ fetchList[ i ] ] = calculator.css(fetchList[ i ]);
            }

            return styles;
        };
    })(),

    listDtdParents: parentOf(&#x27;ol&#x27;)
};

(function () {
    var blockLike = util.merge(dtd.$block, dtd.$listItem, dtd.$tableContent),
        falsyFilter = filters.falsyFilter,
        stylesFilter = filters.stylesFilter,
        createListBulletMarker = utils.createListBulletMarker,
        flattenList = filters.flattenList,
        assembleList = filters.assembleList,
        isListBulletIndicator = utils.isListBulletIndicator,
        containsNothingButSpaces = utils.isContainingOnlySpaces,
        resolveListItem = utils.resolveList,
        convertToPxStr = function (value) {
            value = convertToPx(value);
            return isNaN(value) ? value : value + &#x27;px&#x27;;
        },
        getStyleComponents = utils.getStyleComponents,
        listDtdParents = utils.listDtdParents;

    wordFilter.addRules({

        tagNames: [
            // Remove script, meta and link elements.
            [ ( /meta|link|script/ ), &#x27;&#x27; ]
        ],

        root: function (element) {
            element.filterChildren();
            assembleList(element);
        },

        tags: {
            &#x27;^&#x27;: function (element) {
                // Transform CSS style declaration to inline style.
                var applyStyleFilter;
                if (UA.gecko &amp;&amp; ( applyStyleFilter = filters.applyStyleFilter )) {
                    applyStyleFilter(element);
                }
            },

            $: function (element) {
                var tagName = element.nodeName || &#x27;&#x27;;

                // Convert length unit of width/height on blocks to
                // a more editor-friendly way (px).
                if (tagName in blockLike &amp;&amp; element.getAttribute(&#x27;style&#x27;)) {
                    setStyle(element, stylesFilter(
                        [
                            [ ( /^(:?width|height)$/ ), null, convertToPxStr ]
                        ])(element.getAttribute(&#x27;style&#x27;)));
                }

                // Processing headings.
                if (tagName.match(/h\d/)) {
                    element.filterChildren();
                    // Is the heading actually a list item?
                    if (resolveListItem(element)) {
                        return;
                    }
                }
                // Remove inline elements which contain only empty spaces.
                else if (tagName in dtd.$inline) {
                    element.filterChildren();
                    if (containsNothingButSpaces(element)) {
                        element.setTagName(null);
                    }
                }
                // Remove element with ms-office namespace,
                // with it&#x27;s content preserved, e.g. &#x27;o:p&#x27;.
                else if (tagName.indexOf(&#x27;:&#x27;) !== -1 &amp;&amp; tagName.indexOf(&#x27;ke&#x27;) === -1) {
                    element.filterChildren();

                    // Restore image real link from vml.
                    if (tagName === &#x27;v:imagedata&#x27;) {
                        var href = element.getAttribute(&#x27;o:href&#x27;);
                        if (href) {
                            element.setAttribute(&#x27;src&#x27;, href);
                        }
                        element.setTagName(&#x27;img&#x27;);
                        return;
                    }
                    element.setTagName(null);
                }

                // Assembling list items into a whole list.
                if (tagName in listDtdParents) {
                    element.filterChildren();
                    assembleList(element);
                }
            },

            // We&#x27;ll drop any style sheet, but Firefox conclude
            // certain styles in a single style element, which are
            // required to be changed into inline ones.
            &#x27;style&#x27;: function (element) {
                if (UA.gecko) {
                    // Grab only the style definition section.
                    var styleDefSection = onlyChild(element).nodeValue
                            .match(/\/\* Style Definitions \*\/([\s\S]*?)\/\*/),
                        styleDefText = styleDefSection &amp;&amp; styleDefSection[ 1 ],
                        rules = {}; // Storing the parsed result.

                    if (styleDefText) {
                        styleDefText
                            // Remove line-breaks.
                            .replace(/[\n\r]/g, &#x27;&#x27;)
                            // Extract selectors and style properties.
                            .replace(/(.+?)\{(.+?)\}/g,
                            function (rule, selectors, styleBlock) {
                                selectors = selectors.split(&#x27;,&#x27;);
                                var length = selectors.length;
                                for (var i = 0; i &lt; length; i++) {
                                    // Assume MS-Word mostly generate only simple
                                    // selector( [Type selector][Class selector]).
                                    util.trim(selectors[ i ])
                                        .replace(/^(\w+)(\.[\w-]+)?$/g,
                                        function (match, tagName, className) {
                                            tagName = tagName || &#x27;*&#x27;;
                                            className = className.substring(1, className.length);

                                            // Reject MS-Word Normal styles.
                                            if (className.match(/MsoNormal/)) {
                                                return;
                                            }

                                            if (!rules[ tagName ]) {
                                                rules[ tagName ] = {};
                                            }
                                            if (className) {
                                                rules[ tagName ][ className ] = styleBlock;
                                            } else {
                                                rules[ tagName ] = styleBlock;
                                            }
                                        });
                                }
                            });

                        filters.applyStyleFilter = function (element) {
                            var name = rules[ &#x27;*&#x27; ] ? &#x27;*&#x27; : element.nodeName,
                                className = element.getAttribute(&#x27;class&#x27;),
                                style;
                            if (name in rules) {
                                style = rules[ name ];
                                if (typeof style === &#x27;object&#x27;) {
                                    style = style[ className ];
                                }
                                // Maintain style rules priorities.
                                if (style) {
                                    addStyle(element, style, true);
                                }
                            }
                        };
                    }
                }
                return false;
            },

            &#x27;p&#x27;: function (element) {
                // This&#x27;s a fall-back approach to recognize list item in FF3.6,
                // as it&#x27;s not perfect as not all list style (e.g. &#x27;heading list&#x27;) is shipped
                // with this pattern. (#6662)
                if (/MsoListParagraph/.exec(element.getAttribute(&#x27;class&#x27;))) {
                    var bulletText = firstChild(element, function (node) {
                        return node.nodeType === 3 &amp;&amp; !containsNothingButSpaces(node.parentNode);
                    });
                    var bullet = bulletText &amp;&amp; bulletText.parentNode;
                    if (bullet &amp;&amp; !bullet.getAttribute(&#x27;style&#x27;)) {
                        bullet.setAttribute(&#x27;style&#x27;, &#x27;mso-list: Ignore;&#x27;);
                    }
                }

                element.filterChildren();
                // Is the paragraph actually a list item?
                resolveListItem(element);
            },

            &#x27;div&#x27;: function (element) {
                // Aligned table with no text surrounded is represented by a wrapper div, from which
                // table cells inherit as text-align styles, which is wrong.
                // Instead we use a clear-float div after the table to properly achieve the same layout.
                var singleChild = onlyChild(element);
                if (singleChild &amp;&amp; singleChild.nodeName === &#x27;table&#x27;) {
                    var attrs = element.attributes;

                    util.each(attrs, function (attr) {
                        singleChild.setAttribute(attr.name, attr.value);
                    });

                    if (element.getAttribute(&#x27;style&#x27;)) {
                        addStyle(singleChild, element.getAttribute(&#x27;style&#x27;));
                    }

                    var clearFloatDiv = new HtmlParser.Tag(&#x27;div&#x27;);
                    addStyle(clearFloatDiv, &#x27;clear&#x27;, &#x27;both&#x27;);
                    element.appendChild(clearFloatDiv);
                    element.setTagName(null);
                }
            },

            &#x27;td&#x27;: function (element) {
                // &#x27;td&#x27; in &#x27;thead&#x27; is actually &lt;th&gt;.
                if (getAncestor(element, &#x27;thead&#x27;)) {
                    element.setTagName(&#x27;th&#x27;);
                }
            },

            // MS-Word sometimes present list as a mixing of normal list
            // and pseudo-list, normalize the previous ones into pseudo form.
            &#x27;ol&#x27;: flattenList,
            &#x27;ul&#x27;: flattenList,
            &#x27;dl&#x27;: flattenList,

            &#x27;font&#x27;: function (element) {
                // Drop the font tag if it comes from list bullet text.
                if (isListBulletIndicator(element.parentNode)) {
                    element.setTagName(null);
                    return;
                }

                element.filterChildren();

                var styleText = element.getAttribute(&#x27;style&#x27;),
                    parent = element.parentNode;

                if (&#x27;font&#x27; === parent.name)     // Merge nested &lt;font&gt; tags.
                {
                    util.each(element.attributes, function (attr) {
                        parent.setAttribute(attr.name, attr.value);
                    });
                    if (styleText) {
                        addStyle(parent, styleText);
                    }
                    element.setTagName(null);
                }
                // Convert the merged into a span with all attributes preserved.
                else {
                    styleText = styleText || &#x27;&#x27;;
                    // IE&#x27;s having those deprecated attributes, normalize them.
                    if (element.getAttribute(&#x27;color&#x27;)) {
                        if (element.getAttribute(&#x27;color&#x27;) !== &#x27;#000000&#x27;) {
                            styleText += &#x27;color:&#x27; + element.getAttribute(&#x27;color&#x27;) + &#x27;;&#x27;;
                        }
                        element.removeAttribute(&#x27;color&#x27;);
                    }
                    if (element.getAttribute(&#x27;face&#x27;)) {
                        styleText += &#x27;font-family:&#x27; + element.getAttribute(&#x27;face&#x27;) + &#x27;;&#x27;;
                        element.removeAttribute(&#x27;face&#x27;);
                    }
                    var size = element.getAttribute(&#x27;size&#x27;);
                    // TODO: Mapping size in ranges of xx-small,
                    // x-small, small, medium, large, x-large, xx-large.
                    if (size) {
                        styleText += &#x27;font-size:&#x27; +
                            (size &gt; 3 ? &#x27;large&#x27;
                                : ( size &lt; 3 ? &#x27;small&#x27; : &#x27;medium&#x27; ) ) + &#x27;;&#x27;;
                        element.removeAttribute(&#x27;size&#x27;);
                    }
                    element.setTagName(&#x27;span&#x27;);
                    addStyle(element, styleText);
                }
            },

            &#x27;span&#x27;: function (element) {
                // Remove the span if it comes from list bullet text.
                if (isListBulletIndicator(element.parentNode)) {
                    return false;
                }
                element.filterChildren();
                if (containsNothingButSpaces(element)) {
                    element.setTagName(null);
                    return null;
                }

                // List item bullet type is supposed to be indicated by
                // the text of a span with style &#x27;mso-list : Ignore&#x27; or an image.
                if (isListBulletIndicator(element)) {
                    var listSymbolNode = firstChild(element, function (node) {
                        return node.nodeValue || node.nodeName === &#x27;img&#x27;;
                    });

                    var listSymbol = listSymbolNode &amp;&amp; ( listSymbolNode.nodeValue || &#x27;l.&#x27; ),
                        listType = listSymbol &amp;&amp; listSymbol.match(/^(?:[(]?)([^\s]+?)([.)]?)$/);

                    if (listType) {
                        var marker = createListBulletMarker(listType, listSymbol);
                        // Some non-existed list items might be carried by an inconsequential list,
                        // indicate by &#x27;mso-hide:all/display:none&#x27;,
                        // those are to be removed later, now mark it with &#x27;ke:ignored&#x27;.
                        var ancestor = getAncestor(element, &#x27;span&#x27;);
                        if (ancestor &amp;&amp; (/ mso-hide:\s*all|display:\s*none /).
                            test(ancestor.getAttribute(&#x27;style&#x27;))) {
                            marker.setAttribute(&#x27;ke:ignored&#x27;, 1);
                        }
                        return marker;
                    }
                }

                // Update the src attribute of image element with href.
                var styleText = element.getAttribute(&#x27;style&#x27;);

                // Assume MS-Word mostly carry font related styles on &lt;span&gt;,
                // adapting them to editor&#x27;s convention.
                if (styleText) {

                    setStyle(element, stylesFilter(
                        [
                            // Drop &#x27;inline-height&#x27; style which make lines overlapping.
                            [ /^line-height$/ ],
                            [  /^font-family$/  ] ,
                            [  /^font-size$/  ] ,
                            [  /^color$/  ] ,
                            [  /^background-color$/  ]
                        ]
                    )(styleText, element));
                }
            },
            // Editor doesn&#x27;t support anchor with content currently (#3582),
            // drop such anchors with content preserved.
            &#x27;a&#x27;: function (element) {
                var href;
                if (!(href = element.getAttribute(&#x27;href&#x27;)) &amp;&amp; element.getAttribute(&#x27;name&#x27;)) {
                    element.setTagName(null);
                } else if (UA.webkit &amp;&amp; href &amp;&amp; href.match(/file:\/\/\/[\S]+#/i)) {
                    element.setAttribute(&#x27;href&#x27;, href.replace(/file:\/\/\/[^#]+/i, &#x27;&#x27;));
                }
            },
            &#x27;ke:listbullet&#x27;: function (element) {
                if (getAncestor(element, /h\d/)) {
                    element.setTagName(null);
                }
            }
        },

        attributeNames: [
            // Remove onmouseover and onmouseout events (from MS Word comments effect)
            [ ( /^onmouse(:?out|over)/ ), &#x27;&#x27; ],
            // Onload on image element.
            [ ( /^onload$/ ), &#x27;&#x27; ],
            // Remove office and vml attribute from elements.
            [ ( /(?:v|o):\w+/ ), &#x27;&#x27; ],
            // Remove lang/language attributes.
            [ ( /^lang/ ), &#x27;&#x27; ]
        ],

        attributes: {
            // Provide a white-list of styles that we preserve, those should
            // be the ones that could later be altered with editor tools.
            &#x27;style&#x27;: stylesFilter([
                    [ ( /^list-style-type$/ ) ],

                    // Preserve margin-left/right which used as default indent style in the editor.
                    [ ( /^margin$|^margin-(?!bottom|top)/ ), null, function (value, element, name) {
                        if (element.nodeName in { p: 1, div: 1 }) {
                            var indentStyleName = &#x27;margin-left&#x27;;

                            // Extract component value from &#x27;margin&#x27; shorthand.
                            if (name === &#x27;margin&#x27;) {
                                value = getStyleComponents(name, value,
                                    [ indentStyleName ])[ indentStyleName ];
                            } else if (name !== indentStyleName) {
                                return null;
                            }

                            if (value &amp;&amp; !emptyMarginRegex.test(value)) {
                                return [ indentStyleName, value ];
                            }
                        }

                        return null;
                    } ],

                    // Preserve clear float style.
                    [ ( /^clear$/ ) ],

                    [ ( /^border.*|margin.*|vertical-align|float$/ ), null,
                        function (value, element) {
                            if (element.nodeName === &#x27;img&#x27;) {
                                return value;
                            }
                        } ],

                    [ (/^width|height$/ ), null,
                        function (value, element) {
                            if (element.nodeName in { table: 1, td: 1, th: 1, img: 1 }) {
                                return value;
                            }
                        } ]
                ],
                1),

            // Prefer width styles over &#x27;width&#x27; attributes.
            &#x27;width&#x27;: function (value, element) {
                if (element.nodeName in dtd.$tableContent) {
                    return false;
                }
            },
            // Prefer border styles over table &#x27;border&#x27; attributes.
            &#x27;border&#x27;: function (value, element) {
                if (element.nodeName in dtd.$tableContent) {
                    return false;
                }
            },

            // Only Firefox carry style sheet from MS-Word, which
            // will be applied by us manually. For other browsers
            // the css className is useless.
            &#x27;class&#x27;: falsyFilter,

            // MS-Word always generate &#x27;background-color&#x27; along with &#x27;bgcolor&#x27;,
            // simply drop the deprecated attributes.
            &#x27;bgcolor&#x27;: falsyFilter,

            // Deprecate &#x27;valign&#x27; attribute in favor of &#x27;vertical-align&#x27;.
            &#x27;valign&#x27;: function (value, element) {
                addStyle(element, &#x27;vertical-align&#x27;, value);
                return false;
            }
        },


        // Fore none-IE, some useful data might be buried under these IE-conditional
        // comments where RegExp were the right approach to dig them out where usual approach
        // is transform it into a fake element node which hold the desired data.
        comment: UA.ie ?
            function (value, node) {
                var imageInfo = value.match(/&lt;img.*?&gt;/),
                    listInfo = value.match(/^\[if !supportLists\]([\s\S]*?)\[endif\]$/);

                // Seek for list bullet indicator.
                if (listInfo) {
                    // Bullet symbol could be either text or an image.
                    var listSymbol = listInfo[ 1 ] || ( imageInfo &amp;&amp; &#x27;l.&#x27; ),
                        listType = listSymbol &amp;&amp; listSymbol.match(/&gt;(?:[(]?)([^\s]+?)([.)]?)&lt;/);
                    return createListBulletMarker(listType, listSymbol);
                }

                // Reveal the &lt;img&gt; element in conditional comments for Firefox.
                if (UA.gecko &amp;&amp; imageInfo) {
                    var img = new HtmlParser.Parser(imageInfo[0]).parse().childNodes[ 0 ],
                        previousComment = node.previousSibling,
                    // Try to dig the real image link from vml markup from previous comment text.
                        imgSrcInfo = previousComment &amp;&amp; previousComment.toHtml().match(/&lt;v:imagedata[^&gt;]*o:href=[&#x27;&#x27;](.*?)[&#x27;&#x27;]/),
                        imgSrc = imgSrcInfo &amp;&amp; imgSrcInfo[ 1 ];

                    // Is there a real &#x27;src&#x27; url to be used?
                    if (imgSrc) {
                        ( img.setAttribute(&#x27;src&#x27;, imgSrc) );
                    }
                    return img;
                }

                return false;
            }
            : falsyFilter
    });
})();

module.exports = {
    toDataFormat: function (html, editor) {
        // Firefox will be confused by those downlevel-revealed IE conditional
        // comments, fixing them first( convert it to upperlevel-revealed one ).
        // e.g. &lt;![if !vml]&gt;...&lt;![endif]&gt;
        //&lt;!--[if !supportLists]--&gt;
        // &lt;span style=\&#x27;font-family: Wingdings;\&#x27; lang=\&#x27;EN-US\&#x27;&gt;
        // &lt;span style=\&#x27;\&#x27;&gt;l&lt;span style=\&#x27;font: 7pt &amp;quot;Times New Roman&amp;quot;;\&#x27;&gt;&amp;nbsp;
        // &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
        // &lt;!--[endif]--&gt;

        //变成：

        //&lt;!--[if !supportLists]
        // &lt;span style=\&#x27;font-family: Wingdings;\&#x27; lang=\&#x27;EN-US\&#x27;&gt;
        // &lt;span style=\&#x27;\&#x27;&gt;l&lt;span style=\&#x27;font: 7pt &amp;quot;Times New Roman&amp;quot;;\&#x27;&gt;&amp;nbsp;
        // &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
        // [endif]--&gt;
        if (UA.gecko) {
            html = html.replace(/(&lt;!--\[if[^&lt;]*?\])--&gt;([\S\s]*?)&lt;!--(\[endif\]--&gt;)/gi,
                &#x27;$1$2$3&#x27;);
        }

        // 针对 word 一次
        html = editor.htmlDataProcessor.toDataFormat(html, wordFilter);

        return html;
    }
};
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
